# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../notebooks/ipynb/003_extract_annotation_project.ipynb.

# %% auto 0
__all__ = ['split_array', 'remove_frames_with_no_anno', 'create_detection_yolo', 'write_annotated_image', 'write_label',
           'get_file_frames', 'extract_task_annotation', 'extract_annotations']

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 2
from pathlib import Path
from shutil import copy

import cv2
import numpy as np
import supervision as sv
import torch as t
import yaml
from label_studio_sdk.client import LabelStudio
from label_studio_sdk.converter.brush import decode_rle
from label_studio_sdk.types import Task
from supervision.dataset.formats.yolo import detections_to_yolo_annotations
from tqdm import tqdm

from ..utils import parallel

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 8
def split_array(
    arr: list, train_ratio: float = 0.7, val_ratio: float = 0.2
) -> tuple[list, list, list]:
    """Split array into train/validation/test sets."""
    n = len(arr)
    train_end = int(n * train_ratio)
    val_end = train_end + int(n * val_ratio)

    return arr[:train_end], arr[train_end:val_end], arr[val_end:]

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 9
def remove_frames_with_no_anno(dataset_path: Path) -> None:
    frames = {}
    labels = {}
    for frame_type in ["train", "val", "test"]:
        frames[frame_type] = [
            file.name.split(".")[0]
            for file in dataset_path.joinpath(f"{frame_type}/images").rglob("*.jpg")
        ]
    for label_type in ["train", "val", "test"]:
        labels[label_type] = [
            file.name.split(".")[0]
            for file in dataset_path.joinpath(f"{label_type}/labels").rglob("*.txt")
        ]

    for local_frame_type, local_frames in frames.items():
        local_labels = labels[local_frame_type]
        for frame in local_frames:
            if frame not in local_labels:
                print(f"Removing frame: {frame}.jpg")
                dataset_path.joinpath(f"{local_frame_type}/images/{frame}.jpg").unlink()

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 10
def create_detection_yolo(labels: list[str], frames_path: Path, out_path: Path) -> None:
    # Create directories
    out_path.joinpath("annotated").mkdir(parents=True, exist_ok=True)
    for dir in ["train", "val", "test"]:
        detection_frames_path = out_path / f"{dir}/images"
        detection_labels_path = out_path / f"{dir}/labels"
        detection_frames_path.mkdir(parents=True, exist_ok=True)
        detection_labels_path.mkdir(parents=True, exist_ok=True)

    # Copy existing frames
    all_frames = [file for file in frames_path.glob("*.jpg")]
    train, val, test = split_array(all_frames)
    for split, dir_path in [
        (train, out_path.joinpath("train/images")),
        (val, out_path.joinpath("val/images")),
        (test, out_path.joinpath("test/images")),
    ]:
        for frame in split:
            copy(frame, dir_path.joinpath(frame.name))

    # Write the yaml file
    data_dict = {
        "path": out_path.absolute().__str__(),
        "train": "train/images",
        "val": "val/images",
        "test": "test/images",
        "names": [{i: label} for i, label in enumerate(labels)],
    }
    yaml_out_path = out_path / "data.yaml"
    yaml_out_path.write_text(yaml.dump(data_dict))

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 11
def write_annotated_image(
    detections: sv.Detections, image_path: Path, out_path: Path
) -> None:
    if len(detections) != 0:
        image = cv2.imread(image_path.absolute().__str__())
        box_annotator = sv.BoxAnnotator()
        mask_annotator = sv.MaskAnnotator()
        label_annotator = sv.LabelAnnotator()
        annotated_frame = box_annotator.annotate(scene=image, detections=detections)
        annotated_frame = mask_annotator.annotate(
            scene=annotated_frame, detections=detections
        )
        annotated_frame = label_annotator.annotate(
            scene=annotated_frame, detections=detections
        )
        cv2.imwrite(out_path.absolute().__str__(), annotated_frame)

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 12
def write_label(detections: sv.Detections, out_path: Path, img_shape: tuple) -> None:
    lines = detections_to_yolo_annotations(
        detections=detections,
        image_shape=img_shape,
    )
    if len(lines) != 0:
        out_path.write_text("\n".join(lines))

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 13
def get_file_frames(task_list: list[Task]) -> dict[str, list[int]]:
    frame_dict = {}
    for task in tqdm(task_list):
        filename = task.storage_filename
        filename = filename.split("/")[-1]
        file_parts = filename.split("_")
        if len(file_parts) == 2:
            if frame_dict.get(file_parts[0], None) is None:
                frame_dict[file_parts[0]] = []
            frame_dict[file_parts[0]].append(int(file_parts[1].split(".")[0]))
        else:
            name = "_".join(file_parts[0:2])
            if frame_dict.get(name, None) is None:
                frame_dict[name] = []
            frame_dict[name].append(int(file_parts[2].split(".")[0]))
    return frame_dict

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 14
def extract_task_annotation(
    task_list: list[Task],
    labels: list[str],
    frame_path: Path,
    job_idx: int = 0,
):
    # Make label maps
    label_map = {k: i for i, k in enumerate(labels)}
    label_map_inv = {v: k for k, v in label_map.items()}

    # Collect all frames for annotation
    frame_to_path_dict = {frame.name: frame for frame in frame_path.rglob("*.jpg")}

    # Query labelsutdio api for annotations
    for task in tqdm(task_list, position=job_idx):
        assert task.annotations is not None
        assert task.storage_filename is not None
        filename = task.storage_filename.split("/")[-1]
        out_file_path = frame_to_path_dict[filename]
        out_file_path = out_file_path.parents[1] / "labels" / filename
        out_file_path = out_file_path.with_suffix(".txt")
        if len(task.annotations) == 0:
            # If no annotation is provided then for now skip
            # but in future we will keep the blank frames.txt
            # out_file_path.touch()
            continue

        else:
            print("generating masks")
            masks = []
            classes = []
            scores = []
            img_height = 0
            img_width = 0

            # Collect all annotations for a task
            for anno in task.annotations:
                assert anno["result"] is not None
                for res in anno["result"]:
                    if res["value"].get("brushlabels", None) is not None:
                        curr_label = res["value"]["brushlabels"][0]
                    elif res["value"].get("keypointlabels", None) is not None:
                        curr_label = res["value"]["keypointlabels"][0]
                    else:
                        raise Exception("Unknow label found!")
                    if curr_label not in labels:
                        continue
                    img_width = res["original_width"]
                    img_height = res["original_height"]
                    mask = decode_rle(res["value"]["rle"])
                    mask = np.reshape(mask, [img_height, img_width, 4])[:, :, 3]
                    mask = mask / 255
                    mask = mask.astype(bool)
                    masks.append(mask)
                    classes.append(int(label_map[curr_label]))
                    scores.append(1)

            dets = []
            for i, mask in enumerate(masks):
                detection = sv.Detections.from_transformers(
                    {
                        "scores": t.tensor([scores[i]]),
                        "labels": t.tensor([classes[i]]),
                        "masks": t.tensor(np.array([mask])),
                    },
                    label_map_inv,
                )
                dets.append(detection)
            detections = sv.Detections.merge(dets)
            write_label(detections, out_file_path, (img_height, img_width, 0))
            anno_path = out_file_path.parents[2] / "annotated" / out_file_path.name
            anno_path = anno_path.with_suffix(".jpg")
            write_annotated_image(detections, frame_to_path_dict[filename], anno_path)

# %% ../../../notebooks/ipynb/003_extract_annotation_project.ipynb 15
def extract_annotations(
    client: LabelStudio,
    project_id: int,
    out_path: Path,
    labels: list[str],
    jobs: int = 2,
) -> None:
    # Get project
    project = client.projects.get(id=project_id)

    # Get task
    task_pager = client.tasks.list(project=project.id)
    task_list: list[Task] = [task for task in task_pager]

    # Exrtact in parallel
    parallel(task_list, extract_task_annotation, [labels, out_path], jobs)
